---
title: "R Notebook"
output: html_notebook
---
# Recreating plot of Fig2.A

input data:
1. ExpressionData.RData
2. Cohort.RData

Workflow
1. run edgeR to get insuline resopond gene in OB, POB, NO
2. count overlap of those groups
3. plot barplot


## edgeR workflow
### load the datas
All the data are in Gitlab. Expression count data is loaded.
y will have the matrix data of row with gene and column with sample. The code below, group of the samples are correspond to `cohort$newcond2` which is `Condition`. (Maybe able to rewrite to just `Condition`?)

```{r}
df.pairs<-phase2.female.counts
y <- DGEList(counts=df.pairs,group = cohort$newcond2)
```

Count data is phase2.female.counts and DGEList is to create object for the input of the edgeR.

### Create model
To do Generalized Linear Model (GLM) (which is recommended model to compare multiple groups), we need to set model matrix. `~0+Condition+IDs` is the model equation of this study. `0` explains this model dose not account intercept and not consider background effect of the each groups. ChatGPT say this is good if samples have more possible variables to be effect the expression value.

```{r}
design<-model.matrix(~0+Condition+IDs,data=y$samples)
```

Then first variables "f0" to removed. Why? This is likely a filtering step to remove any unwanted or redundant columns from the matrix. next line is to removes any columns from the design matrix that have zero variance (i.e., the same value in all rows), as these columns will not contribute to the analysis.
```{r}
design <- design[,!grepl("f0", colnames(design))]
design<-design[, colSums(design != 0) > 0]
```


This line will normalize count matrix using RLE method. RLE also used in DESeq. By this, It means, result of edgeR and DESeq will be close? Why not TMM? RLE directly normalize row count and TMM will pre-normalize counts by library sizes. TMM usualy use the whose upper quartile is closest to the mean upper quartile for all the libraries. And RLE performe a geometric mean of all sample values. Maybe bacouse RLE take account of all data so they appried.
```{r}
y <- calcNormFactors(y,norm.method="RLE")
```


This line will caluculate distribution for each gene using binorm-model. Code below takes lot of time becouse culculate for each genes. 
```{r}
y <- estimateDisp(y,design)
```

This will fit the model based on the design.
```{r}
fit <- glmFit(y,design,robust=T)
```

`makeContrasts` will create defines contrasts of interest between different conditions, in this data,  HivsF.NO, HivsF.OB.0, HivsF.OB.2.
(Maybe chage name to HivsF.POB is understandable?)
```{r}
my.contrasts<-makeContrasts(
  HivsF.NO=ConditionNO.h0,
  HivsF.OB.0=ConditionOBESE.h0,
  HivsF.OB.2=ConditionOBESE.h2-ConditionOBESE.f2,
  levels=design)
```



### Run script

```{r}
library(edgeR)

###################################
# loading data
###################################
load("/home/rstudio/work/data/ExpressionTables.RData")
load("/home/rstudio/work/data/Annotation.RData")
load("/home/rstudio/work/data/Cohort.RData")


##################################
# DE analysis of paired samples
###################################
IDs<-paste(cohort$OB_NO,as.factor(cohort$IDs),sep=".")
Condition<-cohort$newcond2
df.pairs<-phase2.female.counts


# DE Analysis
y <- DGEList(counts=df.pairs,group = cohort$newcond2)
design<-model.matrix(~0+Condition+IDs,data=y$samples)
design <- design[,!grepl("f0", colnames(design))]
design<-design[, colSums(design != 0) > 0]
colnames(design)<-make.names(colnames(design))
y <- calcNormFactors(y,norm.method="RLE")
y <- estimateDisp(y,design)
fit <- glmFit(y,design,robust=T)
my.contrasts<-makeContrasts(
  HivsF.NO=ConditionNO.h0,
  HivsF.OB.0=ConditionOBESE.h0,
  HivsF.OB.2=ConditionOBESE.h2-ConditionOBESE.f2,
  levels=design)

contrasts<-colnames(my.contrasts)
myfun <- function(filex) {
  print(filex)
  lrt <- glmLRT(fit, contrast=my.contrasts[,filex])
  out.top=topTags(lrt,n=Inf,adjust.method='BH')
  out.adj=out.top$table
  out.adj.1<-out.adj
  if(nrow(out.adj.1)==0){
    return()
  }else{
    out.adj.1$Contrast<-filex
    out.adj.1$TC<-rownames(out.adj.1)
    out.adj.1$updown<-ifelse(out.adj.1$logFC>0,"up","down")
    return(out.adj.1)
  }
}

y.list<-(lapply(contrasts, myfun))
tab<-do.call(rbind, y.list)
tab$Sign<-ifelse(tab$FDR<0.05,"sign","no")
res.count <- table(tab[tab$Sign=="sign",]$Contrast,tab[tab$Sign=="sign",]$updown )
res.count 

save(tab,file="/home/rstudio/work/data/DE_23NO_23OB_23POB.RData")


```


## count overlap of those groups



### Run script
```{r}
########################## DE tables ##########################
# Extract only DE tc. It also create additional 3 dataframes, one per condition(NO,OBESE and POST-OBESE)
glm<-tab

DE.tab<-function(tabs){
  DE<-tabs[tabs$FDR<0.05,]
  DE<-merge(DE,annotation,by="TC")
  
  return(DE)
}

DE.tab.specific<-function(tabs,contrast){
  out<-tabs[tabs$Contrast==contrast,]
  out$Sign<-ifelse(out$FDR<0.05,"sign","no")
  out<-merge(out,annotation,by="TC")
  out$SignUpDown<-ifelse((out$Sign=="sign" & out$updown=="up"),"up",ifelse((out$Sign=="sign" & out$updown=="down"),"down","non-significant"))
  out$log10FDR<-(-log10(out$FDR))
  return(out)
}

#Overall DE

DE.glm<-DE.tab(glm)
#NO DE tables
NO.glm<-DE.tab.specific(glm,"HivsF.NO")

#OBESE DE tables
OB.glm<-DE.tab.specific(glm,"HivsF.OB.0")

#POST-OBESE DE tables
POB.glm<-DE.tab.specific(glm,"HivsF.OB.2")

########################## DE tables ##########################
# Extract only DE tc. It also create additional 3 dataframes, one per condition(NO,OBESE and POST-OBESE)
glm<-tab

DE.tab<-function(tabs){
  DE<-tabs[tabs$FDR<0.05,]
  DE<-merge(DE,annotation,by="TC")
  
  return(DE)
}

DE.tab.specific<-function(tabs,contrast){
  out<-tabs[tabs$Contrast==contrast,]
  out$Sign<-ifelse(out$FDR<0.05,"sign","no")
  out<-merge(out,annotation,by="TC")
  out$SignUpDown<-ifelse((out$Sign=="sign" & out$updown=="up"),"up",ifelse((out$Sign=="sign" & out$updown=="down"),"down","non-significant"))
  out$log10FDR<-(-log10(out$FDR))
  return(out)
}

#Overall DE

DE.glm<-DE.tab(glm)
#NO DE tables
NO.glm<-DE.tab.specific(glm,"HivsF.NO")

#OBESE DE tables
OB.glm<-DE.tab.specific(glm,"HivsF.OB.0")

#POST-OBESE DE tables
POB.glm<-DE.tab.specific(glm,"HivsF.OB.2")

########################## Add Common_Specific to the overall DE table ##########################

NO_POB<-(intersect(NO.glm[NO.glm$FDR<0.05,]$TC,POB.glm[POB.glm$FDR<0.05,]$TC))
NO_OB<-(intersect(NO.glm[NO.glm$FDR<0.05,]$TC,OB.glm[OB.glm$FDR<0.05,]$TC))
OB_POB<-(intersect(OB.glm[OB.glm$FDR<0.05,]$TC,POB.glm[POB.glm$FDR<0.05,]$TC))
NO_OB_POB<-intersect(intersect(NO.glm[NO.glm$FDR<0.05,]$TC,OB.glm[OB.glm$FDR<0.05,]$TC),POB.glm[POB.glm$FDR<0.05,]$TC)

NO_POB_2<-NO_POB[!NO_POB %in% NO_OB_POB]
NO_OB_2<-NO_OB[!NO_OB %in% NO_OB_POB]
OB_POB_2<-OB_POB[!OB_POB %in% NO_OB_POB]


DE.glm$Comm_Spec<-ifelse(DE.glm$TC %in% NO_POB & (!(DE.glm$TC %in% NO_OB_POB)) ,"NO_POB"  
                         ,ifelse(DE.glm$TC %in% NO_OB & (!(DE.glm$TC %in% NO_OB_POB)),"NO_OB"
                                 ,ifelse(DE.glm$TC %in% OB_POB & (!(DE.glm$TC %in% NO_OB_POB)),"OB_POB"
                                         ,ifelse(DE.glm$TC %in% NO_OB_POB,"NO_OB_POB",DE.glm$Contrast))))
NO_spec<-DE.glm[DE.glm$Comm_Spec=="HivsF.NO",]$TC
OB_spec<-DE.glm[DE.glm$Comm_Spec=="HivsF.OB.0",]$TC
POB_spec<-DE.glm[DE.glm$Comm_Spec=="HivsF.OB.2",]$TC

NO.glm.sign<-unique(merge(NO.glm[NO.glm$FDR<0.05,],DE.glm[, c("TC", "Comm_Spec")], by = "TC"))
OB.glm.sign<-unique(merge(OB.glm[OB.glm$FDR<0.05,],DE.glm[, c("TC", "Comm_Spec")], by = "TC"))
POB.glm.sign<-unique(merge(POB.glm[POB.glm$FDR<0.05,],DE.glm[, c("TC", "Comm_Spec")], by = "TC"))

NO.glm.sign.2<-data.frame(unique(merge(NO.glm,DE.glm[, c("TC", "Comm_Spec")], by = "TC",all.x=T)))
OB.glm.sign.2<-unique(merge(OB.glm,DE.glm[, c("TC", "Comm_Spec")], by = "TC",all.x=T))
POB.glm.sign.2<-unique(merge(POB.glm,DE.glm[, c("TC", "Comm_Spec")], by = "TC",all.x=T))

```


